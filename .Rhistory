if ( T ) {
mYAxisVectorNew = mYAxis - mScreenCoordinate
if ( all(mYAxisVectorNew == 0)) {
mYAxisVectorNew = matrix(c(0,1,0), ncol = 3)
}
mYAxisVectorNew = mYAxisVectorNew / sum(mYAxisVectorNew^2) ^ 0.5
mZAxisVectorNew = mScreenCoordinate - mOrigin
mZAxisVectorNew = mZAxisVectorNew / sum(mZAxisVectorNew^2) ^ 0.5
mXAxisVectorNew = fCrossProduct(mZAxisVectorNew, mYAxisVectorNew)
mXAxisVectorNew = mXAxisVectorNew / sum(mXAxisVectorNew^2) ^ 0.5
mPlaneVectors = mSolutions - matrix( rep(mScreenCoordinate, nrow(mSolutions)), ncol = 3, byrow = T )
vnYCoord = mPlaneVectors %*% t(mYAxisVectorNew)
vnXCoord = mPlaneVectors %*% t(mXAxisVectorNew)
}
mResult = cbind(
x = vnXCoord,
y = vnYCoord
)
mResult
if ( !bTreatAsClosedPolyon ) {
mResult = cbind(mResult, 1)
}
viPointsToFillIn = which(is.na(mResult[, 1]))
if ( length(viPointsToFillIn) ) {
if ( bTreatAsClosedPolyon ) {
viPointsHowToFillInMax = mResult[viPointsToFillIn - 1, 2] > mean(range(mResult[,2], na.rm = T))
mResult[viPointsToFillIn[!viPointsHowToFillInMax], 2] =
min(mResult[,2], na.rm = T) -
# ( 0.0000001 * diff(range(mResult[,2], na.rm = T)) )
0
mResult[viPointsToFillIn[viPointsHowToFillInMax], 2] =
max(mResult[,2], na.rm = T) +
# ( 0.0000001 * diff(range(mResult[,2], na.rm = T)) )
0
mResult[viPointsToFillIn, 1] = ( mResult[viPointsToFillIn - 1, 1] + mResult[viPointsToFillIn + 1, 1] ) / 2
} else {
mResult = cbind(mResult, group = cumsum(is.na(mResult[,1])))
mResult = mResult[-viPointsToFillIn,]
viPointSequence = viPointSequence[-viPointsToFillIn]
}
}
mResult
mResult = cbind(
mResult,
pointSequence = viPointSequence
)
mResult
viPointSequence
mCoordinates = cbind(
dtDimensions[, x],
dtDimensions[, y],
dtDimensions[, z]
)
mCoordinates
viPointSequence = seq(nrow(mCoordinates))
fCrossProduct = function(mZAxisVectorNew, mYAxisVectorNew) {
matrix(
c(
( mZAxisVectorNew[2] * mYAxisVectorNew[3] ) - ( mZAxisVectorNew[3] * mYAxisVectorNew[2] ),
( mZAxisVectorNew[3] * mYAxisVectorNew[1] ) - ( mZAxisVectorNew[1] * mYAxisVectorNew[3] ),
( mZAxisVectorNew[1] * mYAxisVectorNew[2] ) - ( mZAxisVectorNew[2] * mYAxisVectorNew[1] )
),
ncol = 3
)
}
# removing repeat points
if ( nrow(mCoordinates) > 1 ) {
viPointsToKeep = c(T, !rowSums(matrix(apply(mCoordinates, 2, diff), ncol = 3) ^ 2) == 0)
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = mCoordinates[viPointsToKeep,]
if ( bTreatAsClosedPolyon & nrow(mCoordinates) > 1 ) {
if (
all(
mCoordinates[1,] == mCoordinates[nrow(mCoordinates),]
)
) {
viPointSequence = viPointSequence[-nrow(mCoordinates)]
mCoordinates = mCoordinates[-nrow(mCoordinates),]
}
}
}
# mScreenCoordinate = ( ( mOrigin - mScreenCoordinate) * 0.9999 ) + mScreenCoordinate
# mScreenCoordinate = mScreenCoordinate
mZAxisVector = c(mScreenCoordinate[,1:2], mScreenCoordinate[,3] + 1)
# this is the plane on which to project the data
# normal vector = (a,b,c)
# a(x - x1) + b(y - y1) + c(z - z1) = 0
nScreenPlaneCoefficients = c(
mScreenCoordinate[, 1] - mOrigin[, 1],
mScreenCoordinate[, 2] - mOrigin[, 2],
mScreenCoordinate[, 3] - mOrigin[, 3],
0
+ ( ( mScreenCoordinate[, 1] - mOrigin[, 1] ) * mScreenCoordinate[, 1] )
+ ( ( mScreenCoordinate[, 2] - mOrigin[, 2] ) * mScreenCoordinate[, 2]  )
+ ( ( mScreenCoordinate[, 3] - mOrigin[, 3] ) * mScreenCoordinate[, 3]  )
)
# We can't let points all the way till on the screen plane be visualised because
# the coordinates for them will be ~inf. So we'll only include points which
# are at least a little ahead of mScreenCoordinate from the direction of mOrigin
# nDivisionPlaneCoefficients = nScreenPlaneCoefficients, right? Why isn't that working?
mAnotherDivisionPlaneAxisVector = fCrossProduct(
mZAxisVector - mScreenCoordinate,
mScreenCoordinate - mScreenCoordinate
)
# if the above two vectors are parallel, i.e. viewing direction is along z axis
if ( sum(mAnotherDivisionPlaneAxisVector) == 0 ) {
nDivisionPlaneCoefficients = c(
nScreenPlaneCoefficients[1:3],
nScreenPlaneCoefficients[4] - cbind(mScreenCoordinate, 1) %*% nScreenPlaneCoefficients
)
} else {
mAnotherDivisionPlaneAxisVector = ( mAnotherDivisionPlaneAxisVector / sum(mAnotherDivisionPlaneAxisVector ^ 2 ) ^ 0.5 )
nDivisionPlaneCoefficients = fCrossProduct(mZAxisVector - mScreenCoordinate, mAnotherDivisionPlaneAxisVector)
nDivisionPlaneCoefficients = c(
nDivisionPlaneCoefficients,
-sum(nDivisionPlaneCoefficients * mScreenCoordinate)
)
}
# ... i.e on the other side of the plane as the origin
bOriginDestinationInPositiveDirection = sum(nDivisionPlaneCoefficients * c(mOrigin, 1)) < 0
# handling points behind the screen
# retaining at most two points behind the screen should remain for each stretch of points
# behind the screen so that closed polygons from the points ahead of the screen can be
# computed
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
# return empty dataset if all points are behind screen
if ( all(!vbCoordinatesToTransform) ) {
return ( mOrigin[0,] )
}
viRelativeScreenPositionChunks = cumsum(c(1,abs(diff(vbCoordinatesToTransform))))
viPointsToKeep = setdiff(
seq(nrow(mCoordinates)),
unlist(c(lapply(
unique(viRelativeScreenPositionChunks[vbCoordinatesToTransform == F]),
function( iChunk ) {
viIndices = which(viRelativeScreenPositionChunks == iChunk)
if ( length(viIndices) > 2 ) {
viIndicesToRemove = setdiff(viIndices, range(viIndices) )
} else {
viIndicesToRemove = -1
}
viIndicesToRemove
}
)))
)
mCoordinates = mCoordinates[
viPointsToKeep,
]
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = matrix(mCoordinates, ncol = 3)
# if the start and the end stretches of the coordinates are both behind the polygon
# then compress them into a single stretch and cycle the polygon coordinates
# such that the starting coordinate is ahead of the screen
# THIS CHANGES THE ORDER OF POINTS for closed polygons
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
viRelativeScreenPositionChunks = cumsum(c(1,abs(diff(vbCoordinatesToTransform))))
if ( all(!vbCoordinatesToTransform[viRelativeScreenPositionChunks %in% range(viRelativeScreenPositionChunks)]) ) {
viPointsToKeep = max(which(viRelativeScreenPositionChunks == 1)):min(which(viRelativeScreenPositionChunks == max(viRelativeScreenPositionChunks)))
if ( bTreatAsClosedPolyon ) {
viPointsToKeep = c(viPointsToKeep[-1],viPointsToKeep[1])
}
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = mCoordinates[viPointsToKeep, ]
}
mCoordinates = matrix(mCoordinates, ncol = 3)
if ( nrow(mCoordinates) >= 2 ) {
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( vbCoordinatesToTransform[1] == F & vbCoordinatesToTransform[2] == F & !bTreatAsClosedPolyon ) {
viPointSequence = viPointSequence[-1]
mCoordinates = mCoordinates[-1,]
}
}
if ( nrow(mCoordinates) >= 2 ) {
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( vbCoordinatesToTransform[length(vbCoordinatesToTransform)] == F & vbCoordinatesToTransform[length(vbCoordinatesToTransform)-1] == F & !bTreatAsClosedPolyon ) {
viPointSequence = viPointSequence[-nrow(mCoordinates) ]
mCoordinates = mCoordinates[-nrow(mCoordinates), ]
}
}
mCoordinates
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( all(vbCoordinatesToTransform[!is.na(vbCoordinatesToTransform)]) ) {
break
}
viRelativeScreenPositionChunks = cumsum(
c(
1,
abs(
diff(
# sapply(
#     vbCoordinatesToTransform,
#     function(x) ifelse(is.na(x),-1,x)
# )
zoo::na.locf(vbCoordinatesToTransform)
) != 0
)
)
)
viCoordinatesToTransform = table(viRelativeScreenPositionChunks[!vbCoordinatesToTransform])
viCoordinatesToTransform = which(
viRelativeScreenPositionChunks == as.integer(names(viCoordinatesToTransform)[1])
)
# in case it's just one point
viCoordinatesToTransform = range(viCoordinatesToTransform)
if ( viCoordinatesToTransform[2] == 1 & !bTreatAsClosedPolyon ) {
iNextPoint = viCoordinatesToTransform[2] + 1
vnDistancesFromPlane = cbind(mCoordinates[c(viCoordinatesToTransform[2], iNextPoint),], 1) %*% nDivisionPlaneCoefficients
mReplacementPoints = mCoordinates[viCoordinatesToTransform[2], ] - ( diff(mCoordinates[c(iNextPoint, viCoordinatesToTransform[2]),]) * abs(vnDistancesFromPlane[1]) / ( abs(vnDistancesFromPlane[1]) + abs(vnDistancesFromPlane[2]) ) )
viReplacementPointSequence = c(viCoordinatesToTransform[2])
} else if ( viCoordinatesToTransform[1] == nrow(mCoordinates) & !bTreatAsClosedPolyon ) {
iPrevPoint = viCoordinatesToTransform[1] - 1
vnDistancesFromPlane = cbind(
mCoordinates[c(iPrevPoint, viCoordinatesToTransform[1]),],
1) %*% nDivisionPlaneCoefficients
mReplacementPoints = mCoordinates[viCoordinatesToTransform[1], ] - ( diff(mCoordinates[c(iPrevPoint, viCoordinatesToTransform[1]),]) * abs(vnDistancesFromPlane[2]) / ( abs(vnDistancesFromPlane[1]) + abs(vnDistancesFromPlane[2]) ) )
viReplacementPointSequence = c(viCoordinatesToTransform[1])
} else {
iPrevPoint = viCoordinatesToTransform[1] - 1
iNextPoint = viCoordinatesToTransform[2] + 1
iPrevPoint[iPrevPoint == 0] = nrow(mCoordinates)
iNextPoint[iNextPoint == nrow(mCoordinates) + 1] = 1
vnDistancesFromPlane = cbind(mCoordinates[c(iPrevPoint, viCoordinatesToTransform, iNextPoint),], 1) %*% nDivisionPlaneCoefficients
mReplacementPoints = rbind(
mCoordinates[viCoordinatesToTransform[1], ] - ( diff(mCoordinates[c(iPrevPoint, viCoordinatesToTransform[1]),]) * abs(vnDistancesFromPlane[2]) / ( abs(vnDistancesFromPlane[1]) + abs(vnDistancesFromPlane[2]) ) ),
cbind(NA,NA,NA),
mCoordinates[viCoordinatesToTransform[2], ] - ( diff(mCoordinates[c(iNextPoint, viCoordinatesToTransform[2]),]) * abs(vnDistancesFromPlane[3]) / ( abs(vnDistancesFromPlane[3]) + abs(vnDistancesFromPlane[4]) ) )
)
viReplacementPointSequence = c(viCoordinatesToTransform[1], NA, viCoordinatesToTransform[2])
}
if ( viCoordinatesToTransform[1] == 1 ) {
viPointSequence = c(
viReplacementPointSequence,
viPointSequence[-viCoordinatesToTransform]
)
mCoordinates = rbind(
mReplacementPoints,
mCoordinates[-viCoordinatesToTransform, ]
)
} else if ( viCoordinatesToTransform[2] == length(vbCoordinatesToTransform) ) {
viPointSequence = c(
viPointSequence[-viCoordinatesToTransform],
viReplacementPointSequence
)
mCoordinates = rbind(
mCoordinates[-viCoordinatesToTransform, ],
mReplacementPoints
)
} else {
viPointSequence = c(
viPointSequence[1:(viCoordinatesToTransform[1]-1)],
viReplacementPointSequence,
viPointSequence[(viCoordinatesToTransform[2]+1):nrow(mCoordinates)]
)
mCoordinates = rbind(
mCoordinates[1:(viCoordinatesToTransform[1]-1), ],
mReplacementPoints,
mCoordinates[(viCoordinatesToTransform[2]+1):nrow(mCoordinates),]
)
}
mCoordinates
viPointSequence
mCoordinates = cbind(
dtDimensions[, x],
dtDimensions[, y],
dtDimensions[, z]
)
viPointSequence = seq(nrow(mCoordinates))
fCrossProduct = function(mZAxisVectorNew, mYAxisVectorNew) {
matrix(
c(
( mZAxisVectorNew[2] * mYAxisVectorNew[3] ) - ( mZAxisVectorNew[3] * mYAxisVectorNew[2] ),
( mZAxisVectorNew[3] * mYAxisVectorNew[1] ) - ( mZAxisVectorNew[1] * mYAxisVectorNew[3] ),
( mZAxisVectorNew[1] * mYAxisVectorNew[2] ) - ( mZAxisVectorNew[2] * mYAxisVectorNew[1] )
),
ncol = 3
)
}
# removing repeat points
if ( nrow(mCoordinates) > 1 ) {
viPointsToKeep = c(T, !rowSums(matrix(apply(mCoordinates, 2, diff), ncol = 3) ^ 2) == 0)
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = mCoordinates[viPointsToKeep,]
if ( bTreatAsClosedPolyon & nrow(mCoordinates) > 1 ) {
if (
all(
mCoordinates[1,] == mCoordinates[nrow(mCoordinates),]
)
) {
viPointSequence = viPointSequence[-nrow(mCoordinates)]
mCoordinates = mCoordinates[-nrow(mCoordinates),]
}
}
}
# mScreenCoordinate = ( ( mOrigin - mScreenCoordinate) * 0.9999 ) + mScreenCoordinate
# mScreenCoordinate = mScreenCoordinate
mZAxisVector = c(mScreenCoordinate[,1:2], mScreenCoordinate[,3] + 1)
# this is the plane on which to project the data
# normal vector = (a,b,c)
# a(x - x1) + b(y - y1) + c(z - z1) = 0
nScreenPlaneCoefficients = c(
mScreenCoordinate[, 1] - mOrigin[, 1],
mScreenCoordinate[, 2] - mOrigin[, 2],
mScreenCoordinate[, 3] - mOrigin[, 3],
0
+ ( ( mScreenCoordinate[, 1] - mOrigin[, 1] ) * mScreenCoordinate[, 1] )
+ ( ( mScreenCoordinate[, 2] - mOrigin[, 2] ) * mScreenCoordinate[, 2]  )
+ ( ( mScreenCoordinate[, 3] - mOrigin[, 3] ) * mScreenCoordinate[, 3]  )
)
# We can't let points all the way till on the screen plane be visualised because
# the coordinates for them will be ~inf. So we'll only include points which
# are at least a little ahead of mScreenCoordinate from the direction of mOrigin
# nDivisionPlaneCoefficients = nScreenPlaneCoefficients, right? Why isn't that working?
mAnotherDivisionPlaneAxisVector = fCrossProduct(
mZAxisVector - mScreenCoordinate,
mScreenCoordinate - mScreenCoordinate
)
# if the above two vectors are parallel, i.e. viewing direction is along z axis
if ( sum(mAnotherDivisionPlaneAxisVector) == 0 ) {
nDivisionPlaneCoefficients = c(
nScreenPlaneCoefficients[1:3],
nScreenPlaneCoefficients[4] - cbind(mScreenCoordinate, 1) %*% nScreenPlaneCoefficients
)
} else {
mAnotherDivisionPlaneAxisVector = ( mAnotherDivisionPlaneAxisVector / sum(mAnotherDivisionPlaneAxisVector ^ 2 ) ^ 0.5 )
nDivisionPlaneCoefficients = fCrossProduct(mZAxisVector - mScreenCoordinate, mAnotherDivisionPlaneAxisVector)
nDivisionPlaneCoefficients = c(
nDivisionPlaneCoefficients,
-sum(nDivisionPlaneCoefficients * mScreenCoordinate)
)
}
# ... i.e on the other side of the plane as the origin
bOriginDestinationInPositiveDirection = sum(nDivisionPlaneCoefficients * c(mOrigin, 1)) < 0
# handling points behind the screen
# retaining at most two points behind the screen should remain for each stretch of points
# behind the screen so that closed polygons from the points ahead of the screen can be
# computed
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
# return empty dataset if all points are behind screen
if ( all(!vbCoordinatesToTransform) ) {
return ( mOrigin[0,] )
}
viRelativeScreenPositionChunks = cumsum(c(1,abs(diff(vbCoordinatesToTransform))))
viPointsToKeep = setdiff(
seq(nrow(mCoordinates)),
unlist(c(lapply(
unique(viRelativeScreenPositionChunks[vbCoordinatesToTransform == F]),
function( iChunk ) {
viIndices = which(viRelativeScreenPositionChunks == iChunk)
if ( length(viIndices) > 2 ) {
viIndicesToRemove = setdiff(viIndices, range(viIndices) )
} else {
viIndicesToRemove = -1
}
viIndicesToRemove
}
)))
)
mCoordinates = mCoordinates[
viPointsToKeep,
]
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = matrix(mCoordinates, ncol = 3)
# if the start and the end stretches of the coordinates are both behind the polygon
# then compress them into a single stretch and cycle the polygon coordinates
# such that the starting coordinate is ahead of the screen
# THIS CHANGES THE ORDER OF POINTS for closed polygons
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
viRelativeScreenPositionChunks = cumsum(c(1,abs(diff(vbCoordinatesToTransform))))
if ( all(!vbCoordinatesToTransform[viRelativeScreenPositionChunks %in% range(viRelativeScreenPositionChunks)]) ) {
viPointsToKeep = max(which(viRelativeScreenPositionChunks == 1)):min(which(viRelativeScreenPositionChunks == max(viRelativeScreenPositionChunks)))
if ( bTreatAsClosedPolyon ) {
viPointsToKeep = c(viPointsToKeep[-1],viPointsToKeep[1])
}
viPointSequence = viPointSequence[viPointsToKeep]
mCoordinates = mCoordinates[viPointsToKeep, ]
}
mCoordinates = matrix(mCoordinates, ncol = 3)
if ( nrow(mCoordinates) >= 2 ) {
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( vbCoordinatesToTransform[1] == F & vbCoordinatesToTransform[2] == F & !bTreatAsClosedPolyon ) {
viPointSequence = viPointSequence[-1]
mCoordinates = mCoordinates[-1,]
}
}
if ( nrow(mCoordinates) >= 2 ) {
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( vbCoordinatesToTransform[length(vbCoordinatesToTransform)] == F & vbCoordinatesToTransform[length(vbCoordinatesToTransform)-1] == F & !bTreatAsClosedPolyon ) {
viPointSequence = viPointSequence[-nrow(mCoordinates) ]
mCoordinates = mCoordinates[-nrow(mCoordinates), ]
}
}
vbCoordinatesToTransform = c(
bOriginDestinationInPositiveDirection == (
cbind(mCoordinates, 1) %*% nDivisionPlaneCoefficients >= 0
)
)
if ( all(vbCoordinatesToTransform[!is.na(vbCoordinatesToTransform)]) ) {
break
}
viRelativeScreenPositionChunks = cumsum(
c(
1,
abs(
diff(
# sapply(
#     vbCoordinatesToTransform,
#     function(x) ifelse(is.na(x),-1,x)
# )
zoo::na.locf(vbCoordinatesToTransform)
) != 0
)
)
)
viCoordinatesToTransform = table(viRelativeScreenPositionChunks[!vbCoordinatesToTransform])
viCoordinatesToTransform = which(
viRelativeScreenPositionChunks == as.integer(names(viCoordinatesToTransform)[1])
)
# in case it's just one point
viCoordinatesToTransform = range(viCoordinatesToTransform)
bTreatAsClosedPolyon
viCoordinatesToTransform[2] == 1 & !bTreatAsClosedPolyon
iNextPoint = viCoordinatesToTransform[2] + 1
vnDistancesFromPlane = cbind(mCoordinates[c(viCoordinatesToTransform[2], iNextPoint),], 1) %*% nDivisionPlaneCoefficients
mReplacementPoints = mCoordinates[viCoordinatesToTransform[2], ] - ( diff(mCoordinates[c(iNextPoint, viCoordinatesToTransform[2]),]) * abs(vnDistancesFromPlane[1]) / ( abs(vnDistancesFromPlane[1]) + abs(vnDistancesFromPlane[2]) ) )
viReplacementPointSequence = c(viCoordinatesToTransform[2])
viReplacementPointSequence
mReplacementPoints
viCoordinatesToTransform
viPointSequence[c(viCoordinatesToTransform[2])]
viPointSequence[c(viCoordinatesToTransform[1])]
library(POV)
mCoordinates = cbind(
dtDimensions[, x],
dtDimensions[, y],
dtDimensions[, z]
)
mTransformedCoordinates = fGetTransformedCoordinates(
mCoordinates,
mOrigin,
mScreenCoordinate,
bTreatAsClosedPolyon = F
)
mTransformedCoordinates
names(lPitchDimensions$lPitchCoordinates)
mOrigin = cbind(
60,
30,
40
)
mScreenCoordinate = cbind(
70,
35,
0
)
mCoordinates = cbind(
dtDimensions[, x],
dtDimensions[, y],
dtDimensions[, z]
)
names(lPitchDimensions$lPitchCoordinates)
dtDimensions = lPitchDimensions$lPitchCoordinates[[2]]
mCoordinates = cbind(
dtDimensions[, x],
dtDimensions[, y],
dtDimensions[, z]
)
mTransformedCoordinates = fGetTransformedCoordinates(
mCoordinates,
mOrigin,
mScreenCoordinate,
bTreatAsClosedPolyon = F
)
mTransformedCoordinates
mCoordinates
nrow(mCoordinates)
mTransformedCoordinates[,'pointSequence']
